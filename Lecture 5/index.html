<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    
    <title>Lecture 5</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/light.min.css">
    <!--<link rel="stylesheet" href="https://unpkg.com/mvp.css">-->
    <!--<link rel="stylesheet" href="https://latex.now.sh/style.css">-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
    <style>
      .katex { font-size: 1.1em; }
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode {   }
      @media screen {
        pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span.al { color: #ff0000; font-weight: bold; } /* Alert */
      code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
      code span.at { color: #7d9029; } /* Attribute */
      code span.bn { color: #40a070; } /* BaseN */
      code span.bu { } /* BuiltIn */
      code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
      code span.ch { color: #4070a0; } /* Char */
      code span.cn { color: #880000; } /* Constant */
      code span.co { color: #60a0b0; font-style: italic; } /* Comment */
      code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
      code span.do { color: #ba2121; font-style: italic; } /* Documentation */
      code span.dt { color: #902000; } /* DataType */
      code span.dv { color: #40a070; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #40a070; } /* Float */
      code span.fu { color: #06287e; } /* Function */
      code span.im { } /* Import */
      code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
      code span.kw { color: #007020; font-weight: bold; } /* Keyword */
      code span.op { color: #666666; } /* Operator */
      code span.ot { color: #007020; } /* Other */
      code span.pp { color: #bc7a00; } /* Preprocessor */
      code span.sc { color: #4070a0; } /* SpecialChar */
      code span.ss { color: #bb6688; } /* SpecialString */
      code span.st { color: #4070a0; } /* String */
      code span.va { color: #19177c; } /* Variable */
      code span.vs { color: #4070a0; } /* VerbatimString */
      code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
      .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    </style>
    <!--<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>-->
    <script>document.addEventListener("DOMContentLoaded", function () {
    var mathElements = document.getElementsByClassName("math");
    var macros = [];
    /*
    const BATCH_SIZE = 100;
    var i = 0;
    while (i < mathElements.length) {
      const start = i;
      setTimeout(() => {
        for (var j = 0; j < BATCH_SIZE; j++) {
          const i = start + j;
          if (i >= mathElements.length) break;

          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }, 0);
      i += BATCH_SIZE;
    }
    */
    
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
      katex.render(texText.data, mathElements[i], {
        displayMode: mathElements[i].classList.contains('display'),
        throwOnError: false,
        macros: macros,
        fleqn: false
      });
    }}
    
    });
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <h1>Lecture 5</h1>

    <!--
<header id="title-block-header">
<h1 class="title">Lecture 5 — Graph Algorithms 2</h1>
<p class="author">Kenton Lam</p>
<p class="date">2020-09-08</p>
</header>
-->


<h1 id="lecture-5-graph-algorithms-2">Lecture 5 — Graph Algorithms 2</h1>
<p>Recall the shortest path is a sequence of vertices from a particular start to a particular end. The total weight of the path is the sum of all edge paths.</p>
<p>There are several types:</p>
<ul>
<li>Single pair: the shortest path between two given vertexes <span class="math inline">(u, v)</span>.</li>
<li>Single source: Given a vertex <span class="math inline">v</span>, find shortest paths to every other vertex.</li>
<li>Single destination: Given a destination <span class="math inline">v</span>, find shortest paths <em>from</em> every other vertex.</li>
<li>All pairs: Find the shortest path between every pair of vertices.</li>
</ul>
<h2 id="single-source-shortest-path">Single source shortest path</h2>
<p>Given a graph <span class="math inline">G</span> with weight function <span class="math inline">w</span> and source <span class="math inline">s</span>, for each <span class="math inline">v \in G.V</span>, we need to calculate</p>
<ul>
<li><span class="math inline">v.d</span>, its distance from <span class="math inline">s</span>, and</li>
<li><span class="math inline">v.\pi</span>, its predecessor from a shortest path from <span class="math inline">s</span> to <span class="math inline">v</span>.</li>
</ul>
<ol type="1">
<li>We initialise <span class="math inline">s.d=0</span> and <span class="math inline">v.d=\infty</span> else. The invariant here is that the shortest distance from <span class="math inline">s</span> to <span class="math inline">v</span> is less than or equal to <span class="math inline">v.d</span> less than or equal to <span class="math inline">\infty</span>.</li>
<li>Initialise all <span class="math inline">v.\pi = \textit{null}</span>.</li>
<li>Perform a relaxation on the distance estimates until we reach a solution.</li>
</ol>
<h3 id="relax">Relax</h3>
<p>This checks if we can reach <span class="math inline">v</span> (from <span class="math inline">s</span>) sooner by going through <span class="math inline">u</span>. If so, we reduce the distance and update the predecessor.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">def</span> relax(u, v, w):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  <span class="cf">if</span> v.d <span class="op">&gt;</span> u.d <span class="op">+</span> w(u, v):</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    v.d <span class="op">=</span> u.d <span class="op">+</span> w(u, v)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    v.pi <span class="op">=</span> u</span></code></pre></div>
<p>Note that this preserves the distance and predecessor invariants as this only changes if a better path is found.</p>
<h2 id="non-negative-weights">Non-negative weights</h2>
<p>If <span class="math inline">p_n = v_1 \to v_2 \to \cdots \to v_n</span> is a shortest path from <span class="math inline">v_1</span> to <span class="math inline">v_n</span> in a graph with no negative weights, then for all <span class="math inline">1 \le i \le n-1</span>, the prefix <span class="math display">
p_1 = v_1 \to \cdots \to v_i
</span> is in fact a shortest path from <span class="math inline">v_1</span> to <span class="math inline">v_i</span> and we must have <span class="math inline">\operatorname{weight}(p_i) \le \operatorname{weight}(p_n)</span>. This does not hold if some edges have negative weights! There might be edges of negative weight between <span class="math inline">p_i</span> and <span class="math inline">p_n</span>.</p>
<h2 id="dijkstras-algorithm">Dijkstra’s algorithm</h2>
<p>Solves the single-source shortest paths problem for non-negative weighted graphs. A more sophisticated variant called A* is commonly used in computer games.</p>
<ol type="1">
<li>Initialise <span class="math inline">s.d=0</span> and <span class="math inline">v.d=\infty</span> otherwise. Distance invariant is the same.</li>
<li>Initialise <span class="math inline">v.\pi=\textit{null}</span>. Predecessor invariant.</li>
<li>Visit each vertex in order of its distance from the source. For each outgoing edge, we relax along that edge.</li>
</ol>
<p>This is a generalisation of breadth first search to weighted graphs.</p>
<p>How can we efficiently find the next vertex to visit? Let <span class="math inline">S</span> be the set of visited vertices. We will maintain <span class="math inline">Q</span>, a priority queue of vertices <span class="math inline">V-S</span> keyed by <span class="math inline">v.d</span>.</p>
<p>This runs in <span class="math inline">O(E \lg V)</span> with a binary heap or <span class="math inline">O(E + V \lg V)</span> for a Fibonacci heap.</p>
<figure>
<img src="/assets/image-20200908090847384.png" alt="" /><figcaption>image-20200908090847384</figcaption>
</figure>
<h3 id="intuition">Intuition</h3>
<p>When we visit a vertex, we know that we have found the shortest path to <span class="math inline">u</span>. This means the predecessor <span class="math inline">v</span> of <span class="math inline">u</span> may have smaller distance, in which case we already visited it, or equal distance, in which case we have already found a shortest path to <span class="math inline">u</span> with the same length.</p>
<h2 id="negative-weights">Negative weights</h2>
<p>What if we had negative weights? Dijkstra’a algorithm might not relax edges in the correct order. That is, <span class="math inline">(u, v)</span> might be relaxed before we have a shortest path to <span class="math inline">u</span> so this relaxation would be incorrect.</p>
<p>Is the shortest path even well-defined for graphs with negative weight cycles? No, because we can just keep going around that negative cycle to reduce the weight.</p>
<p>Here is an example without negative weight cycles where Dijkstra’s algorithm fails. This goes in order <span class="math inline">a, c, d, b</span> which cannot find the correct shortest path.</p>
<figure>
<img src="/assets/image-20200908092238718.png" alt="" /><figcaption>image-20200908092238718</figcaption>
</figure>
<p>There are two problems here: we need to avoid negative weight cycles, and we need to relax in the correct order.</p>
<h2 id="bellman-ford">Bellman-Ford</h2>
<p>After initialisation, we have found all shortest paths which contain <span class="math inline">\le 0</span> edges. After relaxing each edge once, we have found all shortest paths containing <span class="math inline">\le 1</span> edges. Relaxing all the edges again finds shortest paths of length <span class="math inline">\le 2</span>. Continuing to <span class="math inline">V-1</span> times, we have all shortest paths containing <span class="math inline">\le V-1</span> edges.</p>
<p>The Bellman-Ford algorithm uses this to find single-source shortest paths on directed graphs which may contain negative weight edges. Additionally, it detects negative weight cycles and is able to return false if one is found.</p>
<figure>
<img src="/assets/image-20200908092800492.png" alt="" /><figcaption>image-20200908092800492</figcaption>
</figure>
<p>If there is a negative weight cycle, then even going through <span class="math inline">V-1</span> times is not enough to reduce the shortest path length to minimum. This is because <span class="math inline">V-1</span> is the maximum length of a shortest path with no cycles. We go through the edges once more and if we find another decrease (i.e. another shortest path), we return false.</p>
<p>This algorithm has time complexity <span class="math inline">O(V E)</span>, because it goes through the edges <span class="math inline">V-1</span> times. The worst-case of this is a fully connected graph where <span class="math inline">E=V^2</span>.</p>
<p>This is a generalisation of Dijkstra’s algorithm but runs in much slower time. Is there a more efficient way to find single-source shortest path if the graph is acyclic?</p>
<h2 id="priority-first-search">Priority first search</h2>
<p>This is a generalisation including <strong>Dijkstra’s algorithm</strong> and <strong>Prim’s algorithm</strong> for MST.</p>
<p>Vertices are visited in order of <em>priority</em> (for some definition of priority function). For example, the priority could be the weight (as in Prim’s) or the cumulative distance (as in Dijkstra’s).</p>
<figure>
<img src="/assets/image-20200908093707791.png" alt="" /><figcaption>image-20200908093707791</figcaption>
</figure>
    <p><small>Generated at 11/7/2020, 12:24:41 PM.</small></p>
  </body>
</html>
