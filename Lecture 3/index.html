<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    
    <title>Lecture 3</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/light.min.css">
    <!--<link rel="stylesheet" href="https://unpkg.com/mvp.css">-->
    <!--<link rel="stylesheet" href="https://latex.now.sh/style.css">-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
    <style>
      .katex { font-size: 1.1em; }
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode {   }
      @media screen {
        pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span.al { color: #ff0000; font-weight: bold; } /* Alert */
      code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
      code span.at { color: #7d9029; } /* Attribute */
      code span.bn { color: #40a070; } /* BaseN */
      code span.bu { } /* BuiltIn */
      code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
      code span.ch { color: #4070a0; } /* Char */
      code span.cn { color: #880000; } /* Constant */
      code span.co { color: #60a0b0; font-style: italic; } /* Comment */
      code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
      code span.do { color: #ba2121; font-style: italic; } /* Documentation */
      code span.dt { color: #902000; } /* DataType */
      code span.dv { color: #40a070; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #40a070; } /* Float */
      code span.fu { color: #06287e; } /* Function */
      code span.im { } /* Import */
      code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
      code span.kw { color: #007020; font-weight: bold; } /* Keyword */
      code span.op { color: #666666; } /* Operator */
      code span.ot { color: #007020; } /* Other */
      code span.pp { color: #bc7a00; } /* Preprocessor */
      code span.sc { color: #4070a0; } /* SpecialChar */
      code span.ss { color: #bb6688; } /* SpecialString */
      code span.st { color: #4070a0; } /* String */
      code span.va { color: #19177c; } /* Variable */
      code span.vs { color: #4070a0; } /* VerbatimString */
      code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
      .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    </style>
    <!--<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>-->
    <script>document.addEventListener("DOMContentLoaded", function () {
    var mathElements = document.getElementsByClassName("math");
    var macros = [];
    /*
    const BATCH_SIZE = 100;
    var i = 0;
    while (i < mathElements.length) {
      const start = i;
      setTimeout(() => {
        for (var j = 0; j < BATCH_SIZE; j++) {
          const i = start + j;
          if (i >= mathElements.length) break;

          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }, 0);
      i += BATCH_SIZE;
    }
    */
    
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
      katex.render(texText.data, mathElements[i], {
        displayMode: mathElements[i].classList.contains('display'),
        throwOnError: false,
        macros: macros,
        fleqn: false
      });
    }}
    
    });
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <h1>Lecture 3</h1>

    <!--
<header id="title-block-header">
<h1 class="title">Lecture 3 — Graphs</h1>
<p class="author">Kenton Lam</p>
<p class="date">2020-08-18</p>
</header>
-->


<h1 id="lecture-3-graphs">Lecture 3 — Graphs</h1>
<p>A <strong>graph</strong> is made up of <em>vertices</em> and <em>edges</em> between pairs of vertices.</p>
<figure>
<img src="/assets/image-20200818081442148.png" alt="" /><figcaption>image-20200818081442148</figcaption>
</figure>
<p>Graphs can be used to represent a range of scenarios, including maps, networks, brains, and program control flow.</p>
<p>A graph can be directed or undirected.</p>
<h2 id="undirected-graph">Undirected graph</h2>
<ul>
<li>No self-loops.</li>
<li><span class="math inline">(u, v) \in E(G)</span> means <span class="math inline">v</span> is <strong>adjacent</strong> to <span class="math inline">u</span> and this is symmetric.</li>
<li>We also say <span class="math inline">(u, v)</span> is <strong>incident</strong> <strong>on</strong> <span class="math inline">v</span> and <span class="math inline">u</span>.</li>
<li>The <strong>degree</strong> of a vertex is the number of adjacent edges.</li>
</ul>
<h2 id="directed-graph">Directed graph</h2>
<ul>
<li>Can have self-loops.</li>
<li><span class="math inline">(u, v) \in E(G)</span> means <span class="math inline">v</span> is <strong>adjacent</strong> to <span class="math inline">u</span> and this is not symmetric.</li>
<li>We also say <span class="math inline">(u, v)</span> is <strong>incident from</strong> <span class="math inline">u</span> and <strong>incident to</strong> <span class="math inline">v</span>.</li>
<li>The <strong>out-degree</strong> is the number of edges leaving it.</li>
<li>The <strong>in-degree</strong> is the number of edges entering it.</li>
<li>The <strong>degree</strong> is the sum of in- and out-degrees.</li>
</ul>
<p>Note that the maximum edges in a directed graph is <span class="math inline">n^2</span>, and <span class="math inline">n(n-1)/2</span> for an undirected graph.</p>
<h2 id="weights">Weights</h2>
<p>Another key property of graphs is weights. An edge (directed or undirected) can have weights. This can represent something like distance, similarity, or cost. In a social media friends network, this might be the number of mutual friends.</p>
<h2 id="terminology">Terminology</h2>
<p>A graph <span class="math inline">G</span> is:</p>
<ul>
<li>A <strong>path</strong> of length <span class="math inline">k</span> from <span class="math inline">v_0</span> to <span class="math inline">v_k</span> is a sequence <span class="math inline">\langle v_0, \ldots, v_k\rangle</span> such that <span class="math inline">(v_{i-1}, v_i) \in E</span> for <span class="math inline">i=1, \ldots, k</span>.</li>
<li><span class="math inline">u</span> is <strong>reachable</strong> from <span class="math inline">v</span> if there is any path from <span class="math inline">v</span> to <span class="math inline">u</span>.</li>
<li>A path is <strong>simple</strong> if all vertices in the path are distinct.</li>
<li>A path is a <strong>cycle</strong> if <span class="math inline">v_0=v_k</span> and <span class="math inline">k&gt;1</span> (i.e. not a self-loop).</li>
<li>A cycle is <strong>simple</strong> if it is distinct except for its ends.</li>
<li>A graph with no simple cycles is called <strong>acyclic</strong>.</li>
</ul>
<p>An undirected graph <span class="math inline">G</span> is</p>
<ul>
<li><strong>connected</strong> if every vertex is reachable from any other,</li>
<li>a <strong>forest</strong> if it is acyclic, and</li>
<li>a <strong>tree</strong> if it is a forest with only one connected component.</li>
</ul>
<p>Note that for an undirected graph with <span class="math inline">n</span> vertices, a tree must have <span class="math inline">n-1</span> edges, and a forest can have <span class="math inline">0</span> to <span class="math inline">n-1</span> vertices. In a connected undirected graph, the minimum edges is <span class="math inline">n-1</span> and the maximum is <span class="math inline">n(n-1)/2</span> because we must have connections and the maximum is an arithmetic series.</p>
<p>A directed graph <span class="math inline">G</span> is</p>
<ul>
<li><strong>strongly connected</strong> if any two vertices are reachable from each other.</li>
</ul>
<p>A graph <span class="math inline">G&#39;=(V&#39;, E&#39;)</span> is</p>
<ul>
<li>a <strong>subgraph</strong> of <span class="math inline">G=(V,E)</span> if <span class="math inline">V&#39; \subseteq V</span> and <span class="math inline">E&#39;\subseteq E</span>, and</li>
<li>a <strong>spanning subgraph</strong> if it is a subgraph and <span class="math inline">V&#39;=V</span>.</li>
</ul>
<p>The subgraph of <span class="math inline">G</span> which is <strong>induced by <span class="math inline">V&#39;</span></strong> is <span class="math inline">G&#39;=(V&#39;, E&#39;)</span> where <span class="math inline">E&#39;=\{(u, v) \in E : u \in V&#39; \wedge v \in V&#39;\}</span>. That is, it has all edges which start and end in <span class="math inline">V&#39;</span>.</p>
<h2 id="types-of-graphs">Types of graphs</h2>
<ul>
<li>Directed acyclic graph (DAG)</li>
<li>Connected graph</li>
<li>Trees</li>
<li>Lists can also be seen as simple graphs (see linked lists)</li>
</ul>
<h2 id="representations">Representations</h2>
<p>There are two main ways to represent graphs while programming:</p>
<ul>
<li>adjacency lists, and</li>
<li>adjacency matrices.</li>
</ul>
<p>Representing the sets of vertices and edges directly is often inefficient.</p>
<h3 id="adjacency-list">Adjacency list</h3>
<p>For undirected graphs,</p>
<ul>
<li>the worst-case space complexity is <span class="math inline">\Theta(v + \sum_{v}\operatorname{degree}(v))=\Theta(v+2e) \in \Theta(v+e)</span>,</li>
<li>the time complexity of <span class="math inline">\operatorname*{isAdjacentTo}(u, v)</span> is <span class="math inline">\Theta(v)</span>, and</li>
<li>the time complexity of listing all adjacent vertex pairs is <span class="math inline">\Theta(v+e)</span>.</li>
</ul>
<p>Similarly for directed graphs,</p>
<ul>
<li>the space complexity is <span class="math inline">\Theta(v+e)</span>,</li>
<li>the time complexity if <span class="math inline">\operatorname*{isAdjacentTo}</span> is <span class="math inline">\Theta(v)</span>, and</li>
<li>listing adjacent vertex pairs is <span class="math inline">\Theta(v+e)</span>.</li>
</ul>
<p>However, in this case, the bounds make use of <span class="math inline">\operatorname*{outDegree}</span> instead of just <span class="math inline">\operatorname*{degree}</span> in the derivation.</p>
<h3 id="adjacency-matrix">Adjacency matrix</h3>
<p>An adjacency matrix is a <span class="math inline">v \times v</span> matrix where the <span class="math inline">i,j</span>-th entry indicates if there is an edge from <span class="math inline">i</span> to <span class="math inline">j</span>.</p>
<p>For undirected graphs, the matrix will be symmetric, and</p>
<ul>
<li>the space complexity is <span class="math inline">\Theta(v^2)</span>,</li>
<li>the time complexity of <span class="math inline">\operatorname*{isAdjacentTo}</span> is <span class="math inline">\Theta(1)</span> (because we only check the specific cell), and</li>
<li>the time complexity of listing all adjacent vertex pairs is <span class="math inline">\Theta(v^2)</span>.</li>
</ul>
<p>Note that the optimal representation depends very much on the type of operations we expect to do and the properties of the graphs.</p>
<p>For a directed graph, the complexities are the same but the matrix may be asymmetric.</p>
<h3 id="comparison-of-adjacency-list-and-adjacency-matrix">Comparison of adjacency list and adjacency matrix</h3>
<p>The adjacency list is often more efficient if the graph is sparse, and matrix is better if the graph is dense.</p>
<h2 id="graph-traversal-algorithms">Graph traversal algorithms</h2>
<p>For an unweighted graph <span class="math inline">G</span>,</p>
<ul>
<li>the <strong>length of a path</strong> is the number of edges in that path,</li>
<li>the <strong>distance</strong> from <span class="math inline">u</span> to <span class="math inline">v</span> is the shortest path length from <span class="math inline">u</span> to <span class="math inline">v</span>.</li>
</ul>
<h3 id="breadth-first-search">Breadth-first search</h3>
<p><strong>Breadth-first search</strong> (BFS) takes an unweighted graph and a start vertex <span class="math inline">v_0</span>. It traverses vertices within <span class="math inline">G</span> in order of their distance from <span class="math inline">v_0</span>. It is able to find the shortest path from <span class="math inline">v_0</span> to every other vertex in the graph.</p>
<h4 id="implementation">Implementation</h4>
<p>This can be implemented using a queue (FIFO) data structure, which has operations enqueue and dequeue.</p>
<p>We augment the vertex type with distance, state, and parent fields. The parent fields will be used to obtain the shortest path.</p>
<h3 id="depth-first-search">Depth-first search</h3>
<p>Depth-first search (DFS) does not find the shortest path, but is often used as a subroutine in other algorithms.</p>
<p>It visits a vertex <span class="math inline">v</span> then visiting all unvisited adjacent vertices <span class="math inline">u</span> to <span class="math inline">v</span>.</p>
<p>It has complexity <span class="math inline">\Theta(v) + (\sum_{v}(\Theta(1) + \operatorname*{outDegree}(v)\Theta(1)))=\Theta(v+e)</span>.</p>
<h2 id="topological-sort">Topological sort</h2>
<p>To implement topological sort, we can DFS and add vertices to the end of the list when it has no further unvisited neighbours.</p>
    <p><small>Generated at 9/13/2020, 1:19:15 AM.</small></p>
  </body>
</html>
