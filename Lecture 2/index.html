<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    
    <title>Lecture 2</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/light.min.css">
    <!--<link rel="stylesheet" href="https://unpkg.com/mvp.css">-->
    <!--<link rel="stylesheet" href="https://latex.now.sh/style.css">-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
    <style>
      .katex { font-size: 1.1em; }
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode {   }
      @media screen {
        pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span.al { color: #ff0000; font-weight: bold; } /* Alert */
      code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
      code span.at { color: #7d9029; } /* Attribute */
      code span.bn { color: #40a070; } /* BaseN */
      code span.bu { } /* BuiltIn */
      code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
      code span.ch { color: #4070a0; } /* Char */
      code span.cn { color: #880000; } /* Constant */
      code span.co { color: #60a0b0; font-style: italic; } /* Comment */
      code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
      code span.do { color: #ba2121; font-style: italic; } /* Documentation */
      code span.dt { color: #902000; } /* DataType */
      code span.dv { color: #40a070; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #40a070; } /* Float */
      code span.fu { color: #06287e; } /* Function */
      code span.im { } /* Import */
      code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
      code span.kw { color: #007020; font-weight: bold; } /* Keyword */
      code span.op { color: #666666; } /* Operator */
      code span.ot { color: #007020; } /* Other */
      code span.pp { color: #bc7a00; } /* Preprocessor */
      code span.sc { color: #4070a0; } /* SpecialChar */
      code span.ss { color: #bb6688; } /* SpecialString */
      code span.st { color: #4070a0; } /* String */
      code span.va { color: #19177c; } /* Variable */
      code span.vs { color: #4070a0; } /* VerbatimString */
      code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
      .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    </style>
    <!--<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>-->
    <script>document.addEventListener("DOMContentLoaded", function () {
    var mathElements = document.getElementsByClassName("math");
    var macros = [];
    /*
    const BATCH_SIZE = 100;
    var i = 0;
    while (i < mathElements.length) {
      const start = i;
      setTimeout(() => {
        for (var j = 0; j < BATCH_SIZE; j++) {
          const i = start + j;
          if (i >= mathElements.length) break;

          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }, 0);
      i += BATCH_SIZE;
    }
    */
    
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
      katex.render(texText.data, mathElements[i], {
        displayMode: mathElements[i].classList.contains('display'),
        throwOnError: false,
        macros: macros,
        fleqn: false
      });
    }}
    
    });
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <h1>Lecture 2</h1>

    <!--
<header id="title-block-header">
<h1 class="title">Lecture 2 — Recurrences</h1>
<p class="author">Kenton Lam</p>
</header>
-->


<h1 id="recursive-functions">Recursive functions</h1>
<p>There are three strategies we can use:</p>
<ul>
<li>substitution, where we guess an answer and prove it satisfies the recurrence,</li>
<li>iteration, expanding into a sum and evaluating, and</li>
<li>master theorem which covers some particular cases.</li>
</ul>
<h3 id="divide-and-conquer-algorithms">Divide and conquer algorithms</h3>
<p>Recall merge sort, defined as <span class="math inline">\texttt{merge_sort}(A, p, r)</span>. This also uses a subroutine <span class="math inline">\texttt{merge}(A, p, q, r)</span> which merges the subarrays <span class="math inline">A[p,q]</span> and <span class="math inline">A[q+1, r]</span> into <span class="math inline">A[p, r]</span> (this algorithm is <span class="math inline">\Theta(n)</span> where <span class="math inline">n=r-p+1</span>).</p>
<p>The time complexity of merge sort is <span class="math inline">T(n) = 2T(n/2) + f(n)</span> with <span class="math inline">f(n) \in \Theta(n)</span>.</p>
<h2 id="recurrences">Recurrences</h2>
<p>To be well-defined, a recurrence relation needs a base case and recursive case(s) which converge towards that base case. Sometimes, we omit the base case and implicitly take it as <span class="math inline">T(n) = \Theta(1)</span> for <span class="math inline">n \le c</span>. This does not have a significant effect on the running time of the base case.</p>
<p>Consider a generic divide and conquer algorithm which</p>
<ul>
<li>takes input of size <span class="math inline">n</span>,</li>
<li>breaks it into <span class="math inline">a</span> parts, each of size <span class="math inline">n/b</span>,</li>
<li>takes <span class="math inline">D(n)</span> time to divide the problem in this way, and</li>
<li>takes <span class="math inline">C(n)</span> time to combine the subproblem results.</li>
</ul>
<p>This results in the following recurrence: <span class="math display">
T(n) = \begin{cases}
aT(n/b) + D(n) + C(n), &amp; n \ge c, \\ 
\Theta(1), &amp; n \le c.
\end{cases}
</span></p>
<h2 id="substitution">Substitution</h2>
<p><strong>Example:</strong> Consider <span class="math display">
T(n) = \begin{cases}
2, &amp; n=2,\\
2T(n/2) + n, &amp;n=2^k,
\end{cases}
</span> and we guess that <span class="math display">
T(n) = n \log_2 n.
</span> The base case is that <span class="math inline">T(2) = 2 = 2 \log_2(2)</span>. The inductive step is <span class="math display">
\begin{aligned}
T(n) = 2T(n/2)+n &amp;= 2(n/2)\log_2(n/2) + n \\ 
&amp;= n(\log_2 n - \log_22) + n \\ 
&amp;= n \log_2 n
\end{aligned}
</span> which is what we wanted to show.</p>
<p><strong>Example:</strong> As a more complicated example using <span class="math display">
T(n) =\begin{cases}
1, &amp; n=1, \\ 
2T(\lfloor n/2\rfloor) + n, &amp; n&gt;1.
\end{cases}
</span> We notice it resembles the earlier example and we guess that <span class="math inline">T(n) \in O(n \lg n)</span>. We need to prove this using the definition.</p>
<p>First, we need an <span class="math inline">n_0</span>. We can see that <span class="math inline">n_0=1</span> doesn’t work because <span class="math inline">T(1) = 1</span> which is not less than <span class="math inline">0</span>. Suppose <span class="math inline">n_0=2</span>, then for the cases which depend directly on <span class="math inline">T(1)</span>, we have <span class="math display">
\begin{aligned}
T(2)&amp; = 2T(1) + 2 = 4 \le c2 \lg 2\\
T(3)&amp; = 2T(1) + 3 = 5 \le c 2 \lg 2\\
\end{aligned}
</span> for some <span class="math inline">c \ge 2</span>.</p>
<p>Moving onto the induction, we assume that <span class="math inline">T(n) \le c n \lg n</span> for <span class="math inline">\lfloor n/2\rfloor</span> and we want prove this for the case of <span class="math inline">n</span>. Substituting, <span class="math display">
\begin{aligned}
T(n) = 2T(\lfloor n/2\rfloor) + n  
&amp;\le 2(c \lfloor n/2\rfloor \lg \lfloor n/2\rfloor) + n \\ 
&amp;\le c  n \lg \lfloor n/2\rfloor + n \\ 
&amp;=  c  n (\lg n - \lg 2) + n \\  
&amp;=  cn\lg n - cn\lg 2 + n \\ 
&amp;\le cn \lg n
\end{aligned}
</span> assuming <span class="math inline">c \ge 1</span> and <span class="math inline">n \ge 0</span>.</p>
<p><strong>Example:</strong> Guessing does not always work in this way. Consider, <span class="math display">
T(n) = T(\lfloor n/2 \rfloor) + T(\lceil n/2 \rceil) + 1
</span> and we guess that <span class="math inline">T(n) = O(n)</span> (which is actually correct). Trying to prove the inductive step, we get <span class="math display">
\begin{aligned}
T(n) = T(\lfloor n/2 \rfloor) + T(\lceil n/2 \rceil) + 1 
&amp;\le c(\lfloor n/2 \rfloor) + c(\lceil n/2 \rceil) + 1  \\ 
&amp;=cn+1 
\end{aligned}
</span> which is not <span class="math inline">\le cn</span>, so we cannot prove it this way! We can solve this problem by <em>strenghtening the guess</em>, via subtracting a lower order term. Specifically, we assume that <span class="math inline">T(n) \le cn-b</span> for <span class="math inline">b&gt;0</span>. This does not affect the asymptotic bound but with this stronger assumption, we are able to probe a stronger result.</p>
<p><strong>Note:</strong> In the inductive step, we need to be very precise. We need to prove that <span class="math inline">T(n) \le cn</span> very carefully, something like <span class="math inline">cn + n = O(n)</span> is not good enough.</p>
<h4 id="change-of-variables">Change of variables</h4>
<p>Consider <span class="math display">
T(n) = 2 T(\lfloor \sqrt n \rfloor) + \lg n.
</span> This looks hard, but one trick we can use for some more unfamiliar cases is changing the variables. We try <span class="math inline">m = \lg n</span> which means <span class="math inline">n = 2^m</span>. Making the change, <span class="math display">
T(2^m)=2T(2^{m/2}) + m \iff S(m) = 2S(m/2) + m
</span> where <span class="math inline">S(m) = T^(2^m)</span>. The <span class="math inline">S</span> expression looks familiar and we know the solution is <span class="math inline">S(m) \in \Theta(m \lg m)</span>. Changing back gives us <span class="math display">
T(n) = T(2^{m}) = S(m) = \Theta(m \lg m) = \Theta(\lg n \lg(\lg n)).
</span></p>
<h2 id="iteration">Iteration</h2>
<h2 id="master-method">Master method</h2>
<p>Suppose <span class="math inline">T</span> is of the form <span class="math display">
T(n) = aT(n/b) + f(n)
</span> where <span class="math inline">n/b</span> can also have a ceiling or floor. Then, we need to compare the work at each step, <span class="math inline">f(n)</span> with how many calls there are. Specifically,</p>
<ul>
<li><ol type="1">
<li>if <span class="math inline">n^{\log_b a}</span> is polynomially <em>larger</em> than <span class="math inline">f(n)</span>, then <span class="math inline">T(n) \in \Theta(n^{\log_ba})</span>,</li>
</ol></li>
<li><ol start="2" type="1">
<li>if <span class="math inline">n^{\log_b a}</span> is the same asymptotic <em>tight</em> bound as <span class="math inline">f(n)</span>, then <span class="math inline">T(n) \in \Theta(n^{\log_ba}\lg n)</span>, and</li>
</ol></li>
<li><ol start="3" type="1">
<li>if <span class="math inline">f(n)</span> is polynomially <em>larger</em> than <span class="math inline">n^{\log_ba}</span> and <span class="math inline">f(n)</span> is regular, then <span class="math inline">T(n) \in \Theta(f(n))</span>.</li>
</ol></li>
</ul>
<p>We say a function <span class="math inline">f</span> is <strong>polynomially larger than</strong> <span class="math inline">g</span> if <span class="math inline">f</span> is lower bounded by <span class="math inline">g</span> times some polynomial with degree <span class="math inline">\epsilon&gt;0</span>. That is, <span class="math display">
f(n) \in \Omega(g(n) \times n^\epsilon) \quad \text{where }\epsilon &gt; 0
</span> or equivalently, <span class="math display">
f(n) / g(n) \in \Omega(n^\epsilon).
</span> A function is <strong>regular</strong> if <span class="math inline">af(n/b)&lt; cf(n)</span> for <span class="math inline">c&lt;1</span>. This just ensures that the subproblems are decreasing in complexity.</p>
<p>Putting this together, we have these three cases:</p>
<ul>
<li><ol type="1">
<li><span class="math inline">f(n) \in O(n^{\log_{b}a-\epsilon})\implies T(n) \in \Theta(n^{\log_b a})</span>,</li>
</ol></li>
<li><ol start="2" type="1">
<li><span class="math inline">f(n) \in \Theta(n^{\log_ba})\implies T(n) \in \Theta(n^{\log_b a} \lg n)</span>, and</li>
</ol></li>
<li><ol start="3" type="1">
<li><span class="math inline">f(n) \in \Omega(n^{\log_ba+\epsilon})</span> and regularity <span class="math inline">\implies T(n) \in \Theta(f(n))</span>.</li>
</ol></li>
</ul>
<p><strong>Example:</strong> Consider merge sort from earlier with <span class="math inline">T(n) = 2 T(n/2) + f(n)</span> with <span class="math inline">f(n) \in \Theta(n)</span>. We compare <span class="math inline">f(n)</span> to <span class="math inline">n^{\log_22}=n</span> and we see they are asymptotically the same. As a result, this is case 2 and <span class="math inline">T(n) \in \Omega(n \lg n)</span>.</p>
    <p><small>Generated at 11/7/2020, 12:24:41 PM.</small></p>
  </body>
</html>
